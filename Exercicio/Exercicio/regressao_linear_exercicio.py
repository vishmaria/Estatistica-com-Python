# -*- coding: utf-8 -*-
"""Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/vishmaria/Estatistica-com-Python/blob/main/Exercicio/Exercicio/Regressao%20Linear%20-%20Exercicio.ipynb

## Importando bibliotecas:
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn import metrics

"""## O Dataset e o Projeto

### Fonte: https://www.kaggle.com/greenwing1985/housepricing
Dataset está na pasta "Dados" com o nome "HousePrices_HalfMil.csv" em usa como separador ";".
"""

dados = pd.read_csv('~/Documentos/Códigos/Bootcamp/Estatistica-com-Python/Exercicio/Exercicio/dados/HousePrices_HalfMil.csv',sep=';')

"""## Visualizar os dados:"""

print("Resumo do dataset:\n {}\n".format(dados.head()))

"""## Verificando o tamanho do dataset:"""

print("O dataset de imóveis tem {} registros e {} colunas.\n".format(dados.shape[0],dados.shape[1]))

# Estatísticas descritivas:

print("Estatísticas:\n{}\n".format(dados.describe()))

## Matriz de correlação:

print("Matriz de correlação:\n{}\n".format(dados.corr().round(4)))

# Análises gráficas:

## Módulos utilizados: biblioteca seaborn

## Configure o estilo e cor dos gráficos (opcional)

sns.set_palette('Set2')
sns.set_style('darkgrid')
##  Box plot da variável *dependente* (y)


## Avalie o comportamento da distribuição da variável dependente:

ax = sns.boxplot(data=dados['precos'], orient='v',width=0.5)
ax.set_title('Boxplot de preços', fontsize=18,pad=10)
ax.set_xlabel('Preços $', fontsize=10)

## Investigando a variável *dependente* (y) juntamente com outras características:

## Box-plot (Preço X Garagem)

ax = sns.boxplot(data=dados,y='precos',x='garagem', orient='v')
ax.set_title('Boxplot de preços por vagas de garagem', fontsize=18,pad=10)
ax.set_xlabel('Vagas de garagem', fontsize=10)
ax.set_ylabel('Preços $', fontsize=10)
ax

"""### Box-plot (Preço X Banheiros)"""

ax = sns.boxplot(y='precos',x='banheiros', data=dados, orient='v',width=0.5)
ax.figure.set_size_inches(10,6)
ax.set_title('Boxplot de preços por n. de banheiros', fontsize=18,pad=10)
ax.set_xlabel('Quantidade de banheiros', fontsize=10)
ax.set_ylabel('Preços $', fontsize=10)

"""### Box-plot (Preço X Lareira)"""

ax = sns.boxplot(y='precos',x='lareira', data=dados, orient='v',width=0.5)
ax.figure.set_size_inches(10,6)
ax.set_title('Boxplot de preços por n. de lareiras', fontsize=18,pad=10)
ax.set_xlabel('Quantidade de lareiras', fontsize=10)
ax.set_ylabel('Preços $', fontsize=10)

"""### Box-plot (Preço X Acabamento em Mármore)"""

ax = sns.boxplot(y='precos',x='marmore', data=dados, orient='v',width=0.5)
ax.figure.set_size_inches(10,6)
ax.set_title('Boxplot de preços por acabamento ou não em mármore', fontsize=18,pad=10)
ax.set_xlabel('0 - Sem acabamento em mármore, 1 - com acabamento', fontsize=12)
ax.set_ylabel('Preços $', fontsize=1)

"""### Como foi possível observar na matriz de correlação, o acabamento em mármore em um dos fatores mais influentes no preço.

### Box-plot (Preço X Andares)
"""

ax = sns.boxplot(y='precos',x='andares', data=dados, orient='v',width=0.5)
ax.figure.set_size_inches(10,6)
ax.set_title('Boxplot de preços por n. de andares', fontsize=18,pad=10)
ax.set_xlabel('0 - Casa térrea, 1 - Mais de um andar', fontsize=10)
ax.set_ylabel('Preços $', fontsize=10)

## Distribuição de frequências da variável *dependente* (y)


ax = sns.histplot(data=dados['precos'], kde=True)
ax.set_title('Distribuição de frequência de preços', fontsize=18,pad=10)
ax.set_xlabel('Preços $', fontsize=10)
ax.set_ylabel('Frequência', fontsize=10)

### Pelo gŕafico, a distribuição se assemelha a uma normal. Podemos testar essa hipótese com `normaltest()`:"""

from scipy.stats import normaltest

### Em um teste de normalidade, se o $p-valor$ é **menor ou igual** que a significância, rejeitamos a hipótese nula.
### Nesse caso, `normaltest` testa a hipótese nula de os dados estarem em uma distruibuição normal.


teste = normaltest(dados['precos'])
pvalor = teste[1]
print('É uma distruibuição normal?\n{}\n'.format(pvalor>0.055))
print('p-valor: {}'.format(pvalor))

## Gráficos de dispersão entre as variáveis do dataset

## Plotando o pairplot fixando somente uma variável no eixo y:

ax = sns.pairplot(dados, y_vars='precos', x_vars=['area','garagem','banheiros','lareira','marmore','andares'])
ax.fig.set_size_inches(8,4)
ax.fig.suptitle('Dispersão entre variáveis de preço dos imóveis',
                fontsize=18,y=1.05)

### Para verificar um relação *linear* mais facilmente podemos acrescentar uma reta:

ax = sns.pairplot(
    dados, y_vars='precos',
    x_vars=['area','garagem','banheiros','lareira','marmore','andares'],
    kind='reg'
)
ax.fig.set_size_inches(8,4)
ax.fig.suptitle('Dispersão entre variáveis de preço dos imóveis',
                fontsize=18,y=1.05)


## Módulos: *train_test_split* da biblioteca *scikit-learn*

## Criando uma Series (pandas) para armazenar a variável dependente (y):

y_preco = dados['precos']

## Criando um DataFrame (pandas) para armazenar as variáveis explicativas (X)"""

x = dados[['area','garagem','banheiros','lareira','marmore','andares']]

## Criando os datasets de treino e de teste"""

x_train, x_test, preco_train, preco_test = train_test_split(x,y_preco,test_size=0.3,random_state=2811)

### Usando o mesmo `random_state` das video aulas criamos o mesmo conjunto e podemos comparar resultados.

""" Requisitos: *LinearRegression* e *metrics* da biblioteca *scikit-learn*

https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html

https://scikit-learn.org/stable/modules/classes.html#regression-metrics
"""



## Instanciando a classe *LinearRegression()*"""

modelo = LinearRegression()

## Utilizando o método *fit()* para estimar o modelo linear utilizando os dados de TREINO (y_train e X_train)

modelo.fit(x_train,preco_train)

## Obtendo o coeficiente de determinação (R²) do modelo estimado com os dados de TREINO

print('Coeficiente de correlação R²:\n{}\n'.format(
    modelo.score(x_train,preco_train).round(3)
    )
)

## Gerando previsões para os dados de TESTE (X_test) utilizando o método *predict()*

preco_previsto = modelo.predict(x_test)

## Obtendo o coeficiente de determinação (R²) para as previsões do nosso modelo:

print(
    'R² para previsões:\n{:.3f}\n'.format(
        metrics.r2_score(preco_test,preco_previsto)
    )
)
### `metrics.r2_score()` compara previsões com o valor real da variável dependente $Y$ e `score()` compara os valores previstos e reais das variáveis explicativas.

## Criando um simulador simples:

# def previsao(a, gar, bth, l, mr, andar):
#     x = [[a,gar,bth,l,mr,andar]]
#     print('Preço previsto: ${:.2f}'.format(modelo.predict(x)[0]))

# print("Preço previsto para"
#       " 38 ft², 2 vagas de garagem, 4 banheiros, 4 lareiras e sobrado: {}\n".format(float(previsao(38,2,4,4,0,1))))
# print("Preço previsto para"
#       " 38 ft², 2 vagas de garagem, 4 banheiros, 4 lareiras e acabamento em mármore: {}\n".format(previsao(38,2,4,4,1,0)))
# print("Preço previsto para"
#       " 38 ft², 2 vagas de garagem, 4 banheiros, 4 lareiras, sem mármore ou mais de um andar: {}\n".format(previsao(38,2,4,4,0,0)))


### Erro Quadrático Médio

# Média dos quadrados dos erros. Ajustes melhores apresentam $EQM$ mais baixo.


## Raíz do Erro Quadrático Médio

# Raíz quadrada da média dos quadrados dos erros. Ajustes melhores apresentam raiz de eqm mais baixa.

## Coeficiente de Determinação - R²

# O coeficiente de determinação (R²) é uma medida resumida que diz quanto a linha de regressão ajusta-se aos dados. É um valor entra 0 e 1.

## Obtendo métricas para modelo de preços previsto:

eqm = metrics.mean_squared_error(preco_test,preco_previsto).round(2)
reqm = np.sqrt(eqm).round(2)
r2 = metrics.r2_score(preco_test,preco_previsto).round(2)
metricas = pd.DataFrame([eqm,reqm,r2],['Erro quadrático médio', 'Raiz do erro quadrático médio','R²'],columns=['Métricas de qualidade do modelo'])
print(metricas)
# Salvando e Carregando o Modelo Estimado

## Alternativa: biblioteca `skops`


import skops.io as sio

## Salvando o modelo estimado:

output = sio.dump(modelo,"modelo.skops")

### Em um novo notebook/projeto Python:

"""""
import skops.io as sio

lm_new = sio.load("modelo.skops",Trusted=True)
# unknown_types = sio.get_untrusted_types(file="modelo")
# loaded_model = io.load("pipeline.skops", trusted=unknown_types)

area = 38
garagem = 2
banheiros = 4
lareira = 4
marmore = 0
andares = 1

entrada = [[area, garagem, banheiros, lareira, marmore, andares]]

print('$ {0:.2f}'.format(lm_new.predict(entrada)[0]))
```

<h4 style='color: red; font-weight: normal'>Out [1]:</h4>

```
$ 46389.80
```

"""

## Somente use o parâmetro `Trusted = True` se você confia **100%** na segurança do arquivo sendo aberto.
